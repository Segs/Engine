#include "icall_cs_generator.h"

#include "generator_helpers.h"
#include "type_system.h"
#include "type_mapper.h"

#include "EASTL/sort.h"

namespace  {
static constexpr const char* basic_csproj = R"raw(
    <Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>netstandard2.1</TargetFramework>
        <AssemblyName>%module%Assembly</AssemblyName>
        <GenerateDocumentationFile>true</GenerateDocumentationFile>
    </PropertyGroup>
    <PropertyGroup>
      <DefineConstants>$(DefineConstants);GODOT</DefineConstants>
    </PropertyGroup>
    <ItemGroup>
      <Compile Remove="cpp\**" />
    </ItemGroup>

    <ItemGroup>
      <EmbeddedResource Remove="cpp\**" />
    </ItemGroup>

    <ItemGroup>
      <None Remove="cpp\**" />
    </ItemGroup>

    <ItemGroup>
      %imports%
    </ItemGroup>

</Project>)raw";
static constexpr const char* ref_entry = R"raw(
    <ProjectReference Include="..\%module%\%module%.csproj">
        <Private>false</Private>
    </ProjectReference>

)raw";
}

CsInterfaceVisitor::CsInterfaceVisitor(ProjectContext& ctx) : ReflectionVisitorBase(ctx) {

}

void CsInterfaceVisitor::visit(const ReflectionData *refl)
{
    do_visit_recursive(refl, true, &m_ctx.m_rd != refl);
}

void CsInterfaceVisitor::visitModule(TS_Module* mod)
{
    if (mod->m_imported) { // don't generate anything for imported modules.
        return;
    }
    GeneratorContext csproj;
    m_path_components.emplace_back(mod->m_name);
    csproj.tgt_file_path = String::joined(m_path_components, "/") + "/" + mod->m_name + ".csproj";
    m_path_components.emplace_back("cs");
    String imports="\n";

    for(const auto &dep : mod->m_imports) {
        m_known_imports.emplace(dep->m_name);
        imports += String(ref_entry).replaced("%module%", dep->m_name);
    }
    csproj.append_multiline(String(basic_csproj).replaced("%imports%", imports).replaced("%module%", mod->m_name));
    m_ctx.write_string_builder(csproj.tgt_file_path, csproj.out);

    Super::visitModule(mod); // use parent class functionality for the non-imported case.
    m_path_components.pop_back();
    m_path_components.pop_back();
}

void CsInterfaceVisitor::finalize()
{
    for(const auto &files : m_namespace_files) {
        m_ctx.write_string_builder(files.tgt_file_path,files.out);

    }
}

void CsInterfaceVisitor::visitType(const ProjectContext &ctx, TS_TypeLike *ns)
{
    if(ns->kind()==TS_TypeLike::CLASS) {
        TS_Type *classtype=static_cast<TS_Type *>(ns);
        for(const TS_Function *f : classtype->m_functions) {
            if(!f->m_imported)
                visitFunction(f);
        }
        if(!classtype->m_imported && classtype->source_type->is_singleton) {
            auto& icalls(m_namespace_files.back());
            icalls.append_line("[MethodImpl(MethodImplOptions.InternalCall)]");
            icalls.out.append_indented("internal static extern IntPtr ");
            icalls.out.append(c_special_func_name_to_icall(ns,SpecialFuncType::Singleton));
            icalls.out.append("();\n\n");
        }
        if(!classtype->m_imported && ns->base_type!=nullptr && classtype->source_type->is_instantiable && !classtype->source_type->is_opaque_type) {
            auto& icalls(m_namespace_files.back());
            icalls.append_line("[MethodImpl(MethodImplOptions.InternalCall)]");
            icalls.out.append_indented("internal static extern IntPtr ");
            icalls.out.append(c_special_func_name_to_icall(ns,SpecialFuncType::Constructor));
            icalls.out.append("(");
            icalls.out.append(ns->cs_name());
            icalls.out.append(" obj);\n\n");
        }
    }
    for(TS_TypeLike* chld : ns->m_children) {
        visitType(ctx,chld);
    }
}

void CsInterfaceVisitor::visitNamespace(TS_Namespace *ns)
{
    m_namespace_stack.push_back(ns);
    auto& icalls(m_namespace_files.emplace_back());
    icalls.tgt_file_path = String::joined(m_path_components,"/")+"/"+ns->cs_name() + "_icalls.cs";

    auto imports = m_known_imports.keys();
    eastl::sort(imports.begin(), imports.end());

    icalls.append_line("/* AUTOGENERATED FILE - all changes will be overwritten */");
    icalls.append_line("using System;");
    icalls.append_line("using System.Runtime.CompilerServices;");
    /*for (const auto& imp : imports) {
        icalls.out.append("using ");
        icalls.out.append(imp);
        icalls.out.append(";\n");
    }*/
    icalls.append_line("//End of imports");

    icalls.start_cs_namespace(ns->cs_name());

    if(!ns->m_children.empty()) {
        icalls.out.append_indented("internal static class ");
        assert(m_current_module);
        icalls.out.append(m_current_module->m_name);
        icalls.out.append("NativeCalls\n");
        icalls.start_block();

        for(const auto t : ns->m_children) {
            visitType(m_ctx, t);
        }
        icalls.end_block();
    }

    icalls.end_block("end of namespace");

    m_namespace_stack.pop_back();
}
String CsInterfaceVisitor::mapReturnType(const TS_Function *finfo) {
    TS_TypeMapper &mapper(TS_TypeMapper::get());
    auto mapping = mapper.map_type(TS_TypeMapper::WRAP_TO_SCRIPT_TYPE_OUT,finfo->return_type);
    if(mapping.empty())
        mapping = mapper.map_type(TS_TypeMapper::SCRIPT_TO_WRAP_TYPE,finfo->return_type);

    auto outret_mapping = mapper.map_type(TS_TypeMapper::SCRIPT_TO_WRAP_ARGOUT,finfo->return_type);
    //FIXME: find a better way of detecting/handling output values returned in arguments.
    if(!outret_mapping.empty()) {
        return "void";
    }
    StringView cname(finfo->return_type.type->c_name());
    if(mapping.empty()) {
        return String(String::CtorSprintf(), "MissingReturnMap<%.*s>", (int)cname.length(), cname.data());
    }
    if(mapping.empty()) {
        return String(cname);
    }
    else {
        mapping.replace("%type%",finfo->return_type.type->cs_name());

    }
    return mapping;
}
void CsInterfaceVisitor::mapFunctionArguments(const TS_Function *finfo) {
    TS_TypeMapper &mapper(TS_TypeMapper::get());
    auto &m_cpp_icalls(m_namespace_files.back());

    m_cpp_icalls.out.append("(IntPtr ptr");
    int argc = finfo->arg_types.size();

    for(int i=0; i<argc; ++i) {
        auto mapping = mapper.map_type(TS_TypeMapper::SCRIPT_TO_WRAP_TYPE,finfo->arg_types[i]);
        m_cpp_icalls.out.append(", ");
        if(!mapping.empty())
            m_cpp_icalls.out.append(mapping);
        else {
            m_cpp_icalls.out.append("MissingWrap<");
            m_cpp_icalls.out.append(finfo->arg_types[i].type->c_name());
            m_cpp_icalls.out.append(">");
        }
        m_cpp_icalls.out.append(" ");
        m_cpp_icalls.out.append(finfo->arg_values[i]);
    }
    auto out_mapping = mapper.map_type(TS_TypeMapper::SCRIPT_TO_WRAP_ARGOUT,finfo->return_type);
    if(!out_mapping.empty()) {
        m_cpp_icalls.out.append(", ");
        m_cpp_icalls.out.append(out_mapping.replaced("%input%","_out_val"));
    }
    m_cpp_icalls.out.append(");\n");
}
void CsInterfaceVisitor::visitFunction(const TS_Function *finfo)
{
    //TODO: handle virtual methods better than using call-by-name from c#?
    if (finfo->source_type->is_virtual)
        return;
    if (finfo->m_imported) // skip functions marked as imported
        return;
    //FIXME: sigh...
    if(finfo->c_name()=="free" && finfo->enclosing_type->c_name()=="Object") {
        return;
    }

    auto& icalls(m_namespace_files.back());
    icalls.append_line("[MethodImpl(MethodImplOptions.InternalCall)]");
    icalls.out.append_indented("internal static extern ");
    icalls.out.append(mapReturnType(finfo));
    icalls.out.append(" ");
    icalls.out.append(c_func_name_to_icall(finfo));
    mapFunctionArguments(finfo);
    icalls.out.append("\n");
}
